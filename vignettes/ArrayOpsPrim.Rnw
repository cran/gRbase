%\VignetteIndexEntry{Primitive array operations in the gRbase package}
%\VignettePackage{gRbase}

\documentclass{article}
\usepackage{a4wide}
%\usepackage[T1]{fontenc}
\usepackage{inputenx}
\usepackage{boxedminipage,color}
\title{Primitive array operations in the \texttt{gRbase} package}
\author{S{\o}ren H{\o}jsgaard}
\SweaveOpts{keep.source=T}

\begin{document}

\definecolor{myGray}{rgb}{0.95,0.95,0.95}
\makeatletter
\renewenvironment{Schunk}{
  \begin{lrbox}{\@tempboxa}
    \begin{boxedminipage}
      {\columnwidth}\small}
    {\end{boxedminipage}
  \end{lrbox}%
  \colorbox{myGray}{\usebox{\@tempboxa}}
}
\makeatother

%\renewenvironment{Schunk}{\linespread{.85}\small}{}

\maketitle

\tableofcontents

\parindent0pt\parskip5pt
\def\code#1{{\texttt{#1}}}
\def\R{\texttt{R}}

%%% Text goes here...

% @
% <<echo=F>>=
% source("arrayops-prim.R")
% dyn.load("arrayops-prim.dll")
% @ %def

@
<<echo=F,results=hide>>=
options(useFancyQuotes="UTF-8")
@ %def


@
<<>>=
library(gRbase)
@ %def

\section{Introduction}

This note describes some operations on arrays in \R. These operations
have been implemented to facilitate implementation of graphical models
and Bayesian networks in R.

\subsection{Arrays in \R}
\label{sec:arrays}

The documentation of \R\ states the following about arrays:

\begin{quote}
  An array in R can have one, two or more dimensions. It is simply a
  vector which is stored with additional attributes giving the
  dimensions (attribute "dim") and optionally names for those
  dimensions (attribute "dimnames").

  A two-dimensional array is the same thing as a matrix.

  One-dimensional arrays often look like vectors, but may be handled
  differently by some functions.
\end{quote}

Hence the defining characterstic of an array is that it is a vector
with a dim attribute. For example
@
<<>>=
## 1-dimensional array
##
x1 <- 1:8
dim(x1) <- 8
x1
is.array(x1)
is.matrix(x1)

## 2-dimensional array (matrix)
##
x2 <- 1:8
dim(x2) <- c(2,4)
x2
is.array(x2)
is.matrix(x2)

## 3-dimensional array
##
x3 <- array(1:8, dim=c(2,2,2))
x3
is.array(x3)
is.matrix(x3)
@ %def


\subsection{Terminology}
\label{sec:terminology}

Consider a set  $\Delta=\{\delta_1, \dots, \delta_K\}$ of $|\Delta|=K$
factors where the factor $\delta_k$ has levels
$I_k$. The cross product $I=I_1 \times \dots \times I_K$ defines an
array where $i=(i_1, \dots, i_K) \in I$ is a cell. It is the
convention here that the first factor varies fastest. To each cell $i\in
I$ there is often a value $f(i)$.

As shown above, an array is implemented as a vector $x$ of length
$L=|I|$, that is $x \equiv (f(i), i\in I)$. In practice $x$ is indexed
by an entry $e$ as $x[e]$ for $e=1,\dots, L$.

The factor levels $(I_1, \dots, I_K)$ are denoted \verb'flevels' in
the code below. As an example we take the following:

@
<<>>=
flevels <- c(2,3,2,4)
@ %def

\section{\code{cell2entry()} and \code{entry2cell()}}


The map from a cell to the corresponding
entry is provided by \code{cell2entry()}. The reverse operation, going
from an entry to a cell (which is much less needed) is provided by
\code {entry2cell()}.

@
<<>>=
cell2entry(c(1,1,1,1), flevels)
entry2cell(1, flevels)
cell2entry(c(2,1,2,1), flevels)
entry2cell(8, flevels)
@ %def


@
<<eval=F,echo=F>>=
cell2entry2(c(2,1,2,1), flevels)
cell2entryR(c(2,1,2,1), flevels)
@ %def


%% \paragraph{Timings} :

% These functions are implemented in R, although there is also a
% C--version of \verb'cell2entry()' (which is not as fast because of
% coercion to integers).

% \verb'cell2entry()' is implemented in C (although there is also a
% corresponding R--version), whereas \verb'entry2cell()' purely
% R--based.

@
<<eval=F,echo=F>>=
system.time(for (kk in 1:20000){cell2entry(c(2,1,2,1),flevels)})
system.time(for (kk in 1:20000){cell2entry2(c(2,1,2,1),flevels)})
system.time(for (kk in 1:20000){cell2entryR(c(2,1,2,1),flevels)})
system.time(for (kk in 1:20000){entry2cellR(6,flevels)})
@ %def


\section{\code{nextCell()} and \code{nextCellMarg()}}
\label{sec:x}

Given a cell, say $i=(1,1,2,1)$ we often want to find the next cell in
the table following the convention that the first factor varies
fastest, that is $(2,1,2,1)$. This is provided by
\code{nextCell()}. Notice the result of finding the next cell to the
final cell.

@
<<>>=
nextCell(c(1,1,2,1), flevels)
nextCell(c(2,3,2,4), flevels)
@ %def

% \paragraph{Timings} :

% @
% <<>>=
% system.time(for (kk in 1:100000){nextCell(c(2,1,1,2), flevels)})
% system.time(for (kk in 1:100000){nextCellR(c(2,1,1,2), flevels)})
% @ %def


Given $A\subset \Delta$ and a cell $i_A \in I_A$ consider the cells
$I(i_A)=\{j\in I|j_A = i_A\}$. For example, the cells satisfying that
factor $2$ is at level $1$. Given such a cell, say $(2,1,1,2)$ we often
want to find the next cell also satisfying this constraint following
the convention that the first factor varies fastest, that is
$(1,1,2,2)$. This is provided by \code{nextCellMarg()}.

@
<<>>=
nextCellMarg(c(1,3,2,1),    margset=c(2,3), flevels)
nextCellMarg(c(2,3,2,1),    margset=c(2,3), flevels)
@ %def

% @
% <<>>=
% nextCellMargR(c(1,3,2,1),   margset=c(2,3), flevels)
% nextCellMargR(c(2,3,2,1),   margset=c(2,3), flevels)
% @ %def


% \paragraph{Timings} :

% @
% <<>>=
% system.time(for (kk in 1:100000){nextCellMarg(c(2,1,1,2),  margset=3, flevels)})
% system.time(for (kk in 1:100000){nextCellMargR(c(2,1,1,2), margset=3, flevels)})
% @ %def


\section{\code{margcell2entry()}}
\label{sec:x}

Given $A\subset \Delta$ and a cell $i_A \in I_A$. This cell defines a
slice of the original array, namely the cells
$I(i_A)=\{j\in I|j_A = i_A\}$.
We often want to find the entries in
$x$ for the cells $I(i_A)$. This is provided by
\code{margcell2entry()}. To be specific, we may want the entries for
the cells $(*,1,2,*)$ or $(2,2,*,*)$:
@
<<>>=
margcell2entry(margcell=c(1,2), margset=c(2,3), flevels)
margcell2entry(margcell=c(2,2), margset=c(1,2), flevels)
@ %def


% #.margcell2entry1R(margcell=2, margset=3, flevels)
% #.margcell2entry2R(margcell=2, margset=3, flevels)

% \paragraph{Timings}:

% @
% <<>>=
% system.time(for (kk in 1:10000){margcell2entry(margcell=2, margset=3, flevels)})
% #system.time(for (kk in 1:10000){.margcell2entry1R(margcell=2, margset=3, flevels)})
% #system.time(for (kk in 1:10000){.margcell2entry2R(margcell=2, margset=3, flevels)})
% @ %def



\section{Factorial grids}
\label{sec:factgrid}

Using the operations above we can obtain the combinations of the
factors as a matrix:

@
<<>>=
ff <- factgrid(flevels)
head(ff)
tail(ff)

ff <- factgrid(flevels, margcell=c(1,2), margset=c(2,3))
ff
@ %def


%%% Text ends here...

% @
% <<echo=F>>=
% dyn.unload("arrayops-prim.dll")
% @ %def

\end{document}
